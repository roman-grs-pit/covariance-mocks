"""Plot galaxy catalog from HDF5 file generated by the modular pipeline"""

import argparse
import os
import numpy as np
import matplotlib.pyplot as plt
import h5py
from mpl_toolkits.axes_grid1 import make_axes_locatable
from matplotlib.patches import Rectangle, Circle


def plot_halo_galaxy_scatter(hdf5_path, output_dir=None, n_halos_max=None):
    """Create two-panel scatter plot from HDF5 galaxy catalog
    
    Parameters
    ----------
    hdf5_path : str
        Path to HDF5 file containing galaxy catalog
    output_dir : str, optional
        Output directory for plot. If None, uses same directory as HDF5 file
    n_halos_max : int, optional
        Maximum number of halos to plot. If None, uses all halos
    """
    
    # Read data from HDF5 file
    with h5py.File(hdf5_path, 'r') as f:
        # Load galaxy data
        galaxy_pos = f['galaxies/pos'][:]
        galaxy_mstar = f['galaxies/logsm_t_obs'][:]
        
        # Load halo data
        halo_pos = f['halos/pos'][:]
        halo_logmhost = f['halos/logmhost'][:]
        halo_radius = f['halos/radius'][:]
        
        # Load metadata
        simulation_box = f.attrs['simulation_box'].decode() if isinstance(f.attrs['simulation_box'], bytes) else f.attrs['simulation_box']
        phase = f.attrs['phase'].decode() if isinstance(f.attrs['phase'], bytes) else f.attrs['phase']
        redshift = f.attrs['redshift'].decode() if isinstance(f.attrs['redshift'], bytes) else f.attrs['redshift']
        n_halos = f.attrs['n_halos']
        n_galaxies = f.attrs['n_galaxies']
        Lbox = f.attrs['Lbox']
    
    print(f"Loaded {n_galaxies} galaxies and {n_halos} halos from {hdf5_path}")
    
    # Limit halos if requested
    if n_halos_max is not None and len(halo_pos) > n_halos_max:
        halo_pos = halo_pos[:n_halos_max]
        halo_logmhost = halo_logmhost[:n_halos_max]
        halo_radius = halo_radius[:n_halos_max]
        print(f"Limited to first {n_halos_max} halos for plotting")
    
    # Create two-panel plot
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 8))
    
    # First 25 Mpc/h slice in X direction
    slice_thickness = 25.0  # Mpc/h
    x_min = 0.0
    x_max = slice_thickness
    
    # Halos in first slice
    halo_slice_mask = (halo_pos[:, 0] >= x_min) & (halo_pos[:, 0] <= x_max)
    halo_pos_slice = halo_pos[halo_slice_mask]
    halo_logmhost_slice = halo_logmhost[halo_slice_mask]
    halo_radius_slice = halo_radius[halo_slice_mask]
    
    # Galaxies in first slice
    galaxy_slice_mask = (galaxy_pos[:, 0] >= x_min) & (galaxy_pos[:, 0] <= x_max)
    galaxy_pos_slice = galaxy_pos[galaxy_slice_mask]
    galaxy_mstar_slice = galaxy_mstar[galaxy_slice_mask]
    
    print(f"First slice ({slice_thickness} Mpc/h thick): {len(halo_pos_slice)} halos, {len(galaxy_pos_slice)} galaxies")
    
    # Most massive halo in top-left quadrant (Y < Lbox/2, Z > Lbox/2)
    top_left_mask = (halo_pos_slice[:, 1] < Lbox/2) & (halo_pos_slice[:, 2] > Lbox/2)
    if np.any(top_left_mask):
        top_left_indices = np.where(top_left_mask)[0]
        top_left_masses = halo_logmhost_slice[top_left_indices]
        most_massive_idx = top_left_indices[np.argmax(top_left_masses)]
        zoom_center_y, zoom_center_z = halo_pos_slice[most_massive_idx, 1], halo_pos_slice[most_massive_idx, 2]
        r_100 = halo_radius_slice[most_massive_idx]
        zoom_size = 16 * r_100
        print(f"Zoom inset centered on most massive halo in top-left SLICE at ({zoom_center_y:.1f}, {zoom_center_z:.1f})")
        print(f"Halo virial radius r_100 = {r_100:.2f} Mpc/h")
    else:
        # Fallback: use first halo in slice
        if len(halo_pos_slice) > 0:
            zoom_center_y, zoom_center_z = halo_pos_slice[0, 1], halo_pos_slice[0, 2]
            r_100 = halo_radius_slice[0]
            zoom_size = 16 * r_100
            print(f"No halos in top-left quadrant of slice, using first slice halo for zoom at ({zoom_center_y:.1f}, {zoom_center_z:.1f})")
            print(f"Halo virial radius r_100 = {r_100:.2f} Mpc/h")
        else:
            # No halos in slice
            zoom_center_y, zoom_center_z = Lbox/2, Lbox/2
            r_100 = 5.0
            zoom_size = 16 * r_100
            print(f"No halos in slice, using slice center for zoom at ({zoom_center_y:.1f}, {zoom_center_z:.1f})")
    
    # Left panel: Halo scatter plot
    if len(halo_pos_slice) > 0:
        # Calculate points per data unit for r100 scaling
        main_width_points = 7.5 * 72
        points_per_mpc = main_width_points / Lbox
        
        # Convert virial radius to marker size
        r100_points = halo_radius_slice * points_per_mpc
        scaled_radii = np.pi * r100_points**2
        
        # Limit to 50000 most massive halos
        if len(halo_pos_slice) > 50000:
            # Sort by mass and take the most massive 50000
            mass_sort_idx = np.argsort(halo_logmhost_slice)[::-1][:50000]
            plot_halo_pos = halo_pos_slice[mass_sort_idx]
            plot_halo_logmhost = halo_logmhost_slice[mass_sort_idx]
            plot_halo_radius = halo_radius_slice[mass_sort_idx]
            plot_scaled_radii = scaled_radii[mass_sort_idx]
        else:
            plot_halo_pos = halo_pos_slice
            plot_halo_logmhost = halo_logmhost_slice
            plot_halo_radius = halo_radius_slice
            plot_scaled_radii = scaled_radii
        
        # Find most massive halo in top-left quadrant FROM THE PLOTTED HALOS
        # Top-left quadrant: Y < Lbox/2, Z > Lbox/2
        top_left_mask = (plot_halo_pos[:, 1] < Lbox/2) & (plot_halo_pos[:, 2] > Lbox/2)
        if np.any(top_left_mask):
            top_left_indices = np.where(top_left_mask)[0]
            top_left_masses = plot_halo_logmhost[top_left_indices]
            most_massive_idx = top_left_indices[np.argmax(top_left_masses)]
            zoom_center_y, zoom_center_z = plot_halo_pos[most_massive_idx, 1], plot_halo_pos[most_massive_idx, 2]
            r_100 = plot_halo_radius[most_massive_idx]  # Virial radius of most massive halo
            zoom_size = 16 * r_100
            max_mass = plot_halo_logmhost[most_massive_idx]
            print(f"  Position: Y={zoom_center_y:.1f}, Z={zoom_center_z:.1f}")
            print(f"  Log(M_host) = {max_mass:.3f}")
            print(f"  Virial radius r_100 = {r_100:.2f} Mpc/h")
            print(f"  Zoom size = {zoom_size:.1f} Mpc/h")
        else:
            # Fallback: use first plotted halo if no halos in top-left
            if len(plot_halo_pos) > 0:
                zoom_center_y, zoom_center_z = plot_halo_pos[0, 1], plot_halo_pos[0, 2]
                r_100 = plot_halo_radius[0]
                zoom_size = 16 * r_100
                print(f"No halos in top-left quadrant of plotted halos, using first plotted halo for zoom at ({zoom_center_y:.1f}, {zoom_center_z:.1f})")
                print(f"Halo virial radius r_100 = {r_100:.2f} Mpc/h")
            else:
                # No plotted halos at all - use center of slice
                zoom_center_y, zoom_center_z = Lbox/2, Lbox/2
                r_100 = 5.0
                zoom_size = 16 * r_100
                print(f"No plotted halos, using slice center for zoom at ({zoom_center_y:.1f}, {zoom_center_z:.1f})")
        im1 = ax1.scatter(plot_halo_pos[:, 1], plot_halo_pos[:, 2], 
                         c=plot_halo_logmhost, cmap='plasma', 
                         s=plot_scaled_radii * 2, alpha=0.7, edgecolors='white', linewidth=0.1,
                         vmin=11, vmax=14.5)
    else:
        # No halos in slice at all
        zoom_center_y, zoom_center_z = Lbox/2, Lbox/2
        r_100 = 5.0  # Default radius
        zoom_size = 16 * r_100
        print(f"No halos in slice, using slice center for zoom at ({zoom_center_y:.1f}, {zoom_center_z:.1f})")
        im1 = None
    
    ax1.set_xlabel('y [Mpc/h]')
    ax1.set_ylabel('z [Mpc/h]')
    ax1.set_title(f'{len(plot_halo_pos)} halos in {slice_thickness} Mpc/h slice')
    ax1.set_xlim(0, Lbox)
    ax1.set_ylim(0, Lbox)
    ax1.set_aspect('equal')
    # Set black background
    ax1.set_facecolor('black')
    
    # Right panel: Galaxy scatter plot
    if len(galaxy_pos_slice) > 0:
        # Limit number of galaxies for performance - show most massive galaxies
        if len(galaxy_pos_slice) > 100000:
            # Sort by stellar mass and take the most massive 100000 (already in plot order)
            mstar_sort_idx = np.argsort(galaxy_mstar_slice)[-100000:]
            plot_galaxy_pos = galaxy_pos_slice[mstar_sort_idx]
            plot_galaxy_mstar = galaxy_mstar_slice[mstar_sort_idx]
        else:
            # Sort all galaxies for plotting: least massive first
            plot_order = np.argsort(galaxy_mstar_slice)
            plot_galaxy_pos = galaxy_pos_slice[plot_order]
            plot_galaxy_mstar = galaxy_mstar_slice[plot_order]
        
        # Use small fixed size for galaxies in main panel
        im2 = ax2.scatter(plot_galaxy_pos[:, 1], plot_galaxy_pos[:, 2], 
                         c=plot_galaxy_mstar, cmap='viridis', 
                         s=0.1, alpha=0.8,
                         vmin=9, vmax=11.5)
    else:
        im2 = None
    
    ax2.set_xlabel('y [Mpc/h]')
    ax2.set_ylabel('z [Mpc/h]')
    ax2.set_title(f'{len(plot_galaxy_pos)} galaxies in {slice_thickness} Mpc/h slice')
    ax2.set_xlim(0, Lbox)
    ax2.set_ylim(0, Lbox)
    ax2.set_aspect('equal')
    # Set black background
    ax2.set_facecolor('black')

    # Define zoom region    
    zoom_half_size = zoom_size / 2    
    zoom_corners = [
        (zoom_center_y - zoom_half_size, zoom_center_z - zoom_half_size),  # bottom-left
        (zoom_center_y + zoom_half_size, zoom_center_z - zoom_half_size),  # bottom-right  
        (zoom_center_y + zoom_half_size, zoom_center_z + zoom_half_size),  # top-right
        (zoom_center_y - zoom_half_size, zoom_center_z + zoom_half_size)   # top-left
    ]

    # Create inset for halo panel (left)
    # Position equidistant from top and right edges of left panel
    inset_ax1 = fig.add_axes([0.16, 0.53, 0.23, 0.29])  # [left, bottom, width, height]
    
    # Filter halos within zoom region (from slice)
    zoom_halo_mask = ((halo_pos_slice[:, 1] >= zoom_center_y - zoom_half_size) & 
                      (halo_pos_slice[:, 1] <= zoom_center_y + zoom_half_size) &
                      (halo_pos_slice[:, 2] >= zoom_center_z - zoom_half_size) & 
                      (halo_pos_slice[:, 2] <= zoom_center_z + zoom_half_size))
    
    zoom_halos = halo_pos_slice[zoom_halo_mask]
    zoom_halo_logmhost = halo_logmhost_slice[zoom_halo_mask]
    zoom_halo_radius = halo_radius[halo_slice_mask][zoom_halo_mask]
    
    if len(zoom_halos) > 0:
        # Calculate points per data unit for proper r100 scaling
        # Inset is 0.23 figure width, figure is 18 inches wide, 72 DPI
        inset_width_points = 0.23 * 18 * 72  # ~298 points
        points_per_mpc = inset_width_points / zoom_size  # points per Mpc/h
        
        # Convert virial radius to marker size
        r100_points = zoom_halo_radius * points_per_mpc  # radius in points
        scaled_radii = np.pi * r100_points**2  # area in points^2
        
        # Sort halos by x-coordinate for plotting order
        x_sort_idx = np.argsort(zoom_halos[:, 0])
        zoom_halos_sorted = zoom_halos[x_sort_idx]
        zoom_halo_logmhost_sorted = zoom_halo_logmhost[x_sort_idx]
        scaled_radii_sorted = scaled_radii[x_sort_idx]
        
        inset_ax1.scatter(zoom_halos_sorted[:, 1], zoom_halos_sorted[:, 2], 
                         c=zoom_halo_logmhost_sorted, cmap='plasma', 
                         s=scaled_radii_sorted, alpha=0.7, edgecolors='white', linewidth=0.5,
                         vmin=11, vmax=14.5)
    
    # Format halo inset
    inset_ax1.set_xlim(zoom_center_y - zoom_half_size, zoom_center_y + zoom_half_size)
    inset_ax1.set_ylim(zoom_center_z - zoom_half_size, zoom_center_z + zoom_half_size)
    inset_ax1.tick_params(labelsize=8, colors='white')
    inset_ax1.set_aspect('equal')
    # Set black background and white spines
    inset_ax1.set_facecolor('black')
    for spine in inset_ax1.spines.values():
        spine.set_color('white')
        spine.set_linewidth(1.5)
    
    # Create inset for galaxy panel (right)
    # Position equidistant from top and right edges of right panel
    inset_ax2 = fig.add_axes([0.573, 0.53, 0.23, 0.29])  # [left, bottom, width, height]
    
    # Filter galaxies within zoom region (from slice)
    zoom_galaxy_mask = ((galaxy_pos_slice[:, 1] >= zoom_center_y - zoom_half_size) & 
                        (galaxy_pos_slice[:, 1] <= zoom_center_y + zoom_half_size) &
                        (galaxy_pos_slice[:, 2] >= zoom_center_z - zoom_half_size) & 
                        (galaxy_pos_slice[:, 2] <= zoom_center_z + zoom_half_size))
    
    zoom_galaxies = galaxy_pos_slice[zoom_galaxy_mask]
    zoom_mstar_filtered = galaxy_mstar_slice[zoom_galaxy_mask]
    
    if len(zoom_galaxies) > 0:
        # Sort galaxies by stellar mass for plotting: least massive first
        zoom_plot_order = np.argsort(zoom_mstar_filtered)
        zoom_galaxies_sorted = zoom_galaxies[zoom_plot_order]
        zoom_mstar_sorted = zoom_mstar_filtered[zoom_plot_order]
        
        # Use small fixed size for galaxies - show ALL galaxies in zoom region
        inset_ax2.scatter(zoom_galaxies_sorted[:, 1], zoom_galaxies_sorted[:, 2], 
                         c=zoom_mstar_sorted, cmap='viridis', 
                         s=1.5, alpha=0.8,
                         vmin=9, vmax=11.5)
    
    # Format galaxy inset
    inset_ax2.set_xlim(zoom_center_y - zoom_half_size, zoom_center_y + zoom_half_size)
    inset_ax2.set_ylim(zoom_center_z - zoom_half_size, zoom_center_z + zoom_half_size)
    inset_ax2.tick_params(labelsize=8, colors='white')
    inset_ax2.set_aspect('equal')
    # Set black background and white spines
    inset_ax2.set_facecolor('black')
    for spine in inset_ax2.spines.values():
        spine.set_color('white')
        spine.set_linewidth(1.5)
    
    # Add colorbar for halo mass (left panel)
    if im1 is not None:
        divider1 = make_axes_locatable(ax1)
        cax1 = divider1.append_axes("right", size="5%", pad=0.1)
        cbar1 = fig.colorbar(im1, cax=cax1)
        cbar1.set_label(r'${\rm log}\ M_h\ /\ M_{\odot}$')
    
    # Add colorbar for stellar mass (right panel)
    if im2 is not None:
        divider2 = make_axes_locatable(ax2)
        cax2 = divider2.append_axes("right", size="5%", pad=0.1)
        cbar2 = fig.colorbar(im2, cax=cax2)
        cbar2.set_label(r'${\rm log}\ M_*\ /\ M_{\odot}$')
    
    # Adjust layout for colorbars and insets
    fig.subplots_adjust(bottom=0.1, top=0.9, left=0.05, right=0.78, wspace=0.3)
    
    # Determine output path
    if output_dir is None:
        output_dir = os.path.dirname(hdf5_path)
    
    # Extract base filename to check for test suffix
    base_filename = os.path.basename(hdf5_path)
    if "test" in base_filename:
        # Extract test suffix (e.g., "test5000" from "mock_AbacusSummit_small_c000_ph3000_z1.100_test5000.hdf5")
        test_part = base_filename.split("test")[1].split(".")[0]
        plot_filename = f"halo_galaxy_scatter_{simulation_box}_{phase}_{redshift}_test{test_part}.png"
    else:
        plot_filename = f"halo_galaxy_scatter_{simulation_box}_{phase}_{redshift}.png"
    plot_path = os.path.join(output_dir, plot_filename)
    
    # Save the plot
    plt.savefig(plot_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Saved two-panel scatter plot to: {plot_path}")
    
    return plot_path


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Plot galaxy catalog from HDF5 file")
    parser.add_argument("hdf5_file", help="Path to HDF5 galaxy catalog file")
    parser.add_argument("--output-dir", help="Output directory for plot (default: same as HDF5 file)")
    parser.add_argument("--max-halos", type=int, help="Maximum number of halos to plot (default: auto-detect from filename)")
    
    args = parser.parse_args()
    
    if not os.path.exists(args.hdf5_file):
        raise FileNotFoundError(f"HDF5 file not found: {args.hdf5_file}")
    
    plot_halo_galaxy_scatter(args.hdf5_file, args.output_dir, args.max_halos)